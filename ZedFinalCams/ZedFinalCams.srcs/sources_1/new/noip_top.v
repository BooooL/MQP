`timescale 1ns / 1ps
// Top module for future custom stereo camera IP package
module noip_top(
   input sysclk,
   input reset, // reset 
   input sw,
   input cam_rst, // button for camera RESET_BAR
   input trigger, // button for camera trigger
   output cam_sysclk, // sysclk out to camera
   output cam_reset, // reset_bar out to camera
   output cam_trigger, // trigger out to camera
   input [7:0] FIFO_DATA, // DO[7:0] from AL422b fifo
   output FIFO_OE1, // read enable to fifo (active low)
   output FIFO_RRST1, // read reset to fifo (active low)
   output FIFO_OE2, // read enable to fifo (active low)
   output FIFO_RRST2, // read reset to fifo (active low)
   output FIFO_RCK, // rck to fifo (1MHz)
   output reg [7:0] rgb, // values on vga color pins
   output HS, // horizontal sync (to VGA port)
   output VS, // vertical sync (to VGA port)
   output [3:0] LEDs
   );
    
wire clk_50MHz, clk_25MHz, clk_24MHz, clk_5MHz;
clk_wiz_0 clkgen
   (
   // Clock in ports
    .clkin_100MHz(sysclk),      // input clk_100MHz
    // Clock out ports
    .clk_100MHz(clk_50MHz),     // output clk_50MHz
    .clk_25MHz(clk_25MHz),     // output clk_25MHz
    .clk_24MHz(clk_24MHz),
    .clk_5MHz(clk_5MHz),
    // Status and control signals
    .reset(reset)
);

//wire clk_20Hz;
//clk_divs clks(
//	.reset(reset), // synchronous reset
//    .clk_5MHz(clk_5MHz), // 24MHz clock signal
//    .clk_20Hz(clk_20Hz) // 20Hz clock pulse
//    );
    
assign FIFO_RCK = clk_5MHz;
assign cam_sysclk = clk_24MHz;

// ~~~~~~~~~~ disparity code ~~~~~~~~~~~~~~
wire trig_db;
//debounce deb(
//    .clk(clk_20Hz),
//    .btn(trigger),
//    .btn_val(trig_db)
//    );

wire buffer_ready, result_wen;
wire [2:0] current_state;
wire [16:0] laddr, raddr; 
wire [18:0] result_addr;
wire [7:0] ldata, rdata, result_data;
reg [10:0] lineaddr;
wire [7:0] lineout;
assign trig_db = current_state == 2'b00; // trigger a new sequence when disparity is idling

parallel_disparity disp(
	 .clk(clk_50MHz), // Read clk signal
	 .enable(buffer_ready), // enable new disparity calculation 
	 //.buffer_ready(buffer_ready), // was buffer_ready && ~ trig_db
	 .sw(sw), // added in to parallel module
	 .reset(reset), // reset disparity FSM
	 .ldata(ldata), // FIFO data in
	 .rdata(rdata), // FIFO data in
	 .laddr(laddr),
	 .raddr(raddr),
	 .result_addr(result_addr),
	 .result_data(result_data),
	 .result_wea(result_wen),
	 .state_LED(current_state), // current state indicator
	 .lineout(lineout),
	 .lineaddr(lineaddr)
    );
    
// state indicator LEDs
assign LEDs = {trig_db,current_state[2:0]};

// ~~~~~~~~~~~~~~~~ VGA controller ~~~~~~~~~~~~~~~~~~~~~~
wire [10:0] hcount, vcount;
wire blank;
vga_controller_640_60 vga(
    .rst(reset),
    .pixel_clk(clk_25MHz),
    .HS(HS),
    .VS(VS),
    .hcount(hcount),
    .vcount(vcount),
    .blank(blank)
    );

// ~~~~~~~~~~~~~~~~ Left, right, resultant image buffers ~~~~~~~~~~~~~~~~     
// camera initialization sequence
reg [4:0] init_count = 5'd0;
always @(posedge clk_24MHz) // cam sysclk
begin
	if (cam_rst) // if cam_rst is pressed, redo the initialization sequence
		init_count <= 5'd0;
	else if(init_count < 5'd25) // keep cam_rst asserted for at least 20 cam_sysclk cycles - I use 30 since it's the minimum time for the i2c bus to be ready
		init_count <= init_count + 1'b1;
end
assign cam_reset = (init_count >= 5'd20);

wire fifo_oe, fifo_rrst, image_sel;
assign FIFO_OE1 = (image_sel == 1'b0) ? fifo_oe : 1'b1;
assign FIFO_OE2 = (image_sel == 1'b1) ? fifo_oe : 1'b1;
assign FIFO_RRST1 = (image_sel == 1'b0) ? fifo_rrst : 1'b1;
assign FIFO_RRST2 = (image_sel == 1'b1) ? fifo_rrst : 1'b1;

imgbuf camctl(
    .get_data(trig_db),
	.laddr(laddr),
    .raddr(raddr),
    .ldata(ldata), 
    .rdata(rdata),
	.fifo_data(FIFO_DATA), // 8 bit data in from fifo
	.fifo_rck(clk_5MHz), // 1MHz clock signal generated by FPGA
	.bram_rck(clk_50MHz),
	.image_sel(image_sel),
	.fifo_rrst(fifo_rrst), // fifo read reset (reset read addr pointer to 0)
	.fifo_oe(fifo_oe), // fifo output enable (allow for addr pointer to increment)
	.trigger(cam_trigger),
	.buffer_ready(buffer_ready)
   );

wire [7:0] vga_data;
reg [18:0] vga_addr;     
blk_mem_resultant resultant (
  .clka(clk_50MHz),    // input wire clka
  .ena(result_wen),
  .wea(1'b1),      // input wire [0 : 0] wea
  .addra(result_addr),  // input wire [18 : 0] addra
  .dina(result_data),    // input wire [7 : 0] dina
  .clkb(clk_25MHz),    // input wire clkb
  .addrb(vga_addr),  // input wire [18 : 0] addrb
  .doutb(vga_data)  // output wire [7 : 0] doutb
);
// ~~~~~~~~~~~~~~~~ End of image buffers ~~~~~~~~~~~~~~~~
always @(hcount)
    lineaddr = (hcount >= 128 && hcount < 512) ? hcount-128 : 11'd0;

always @ (hcount,vcount,blank,vga_data)
	if(blank)
		rgb = 8'h00;
	// center 384x288 output in the middle of the screen
    else if(~sw && hcount>= 128 && hcount < 512 && vcount >= 96 && vcount < 384)
        rgb = vga_data;
    else if(sw && hcount >= 128 && hcount < 512)
        if(vcount == 265-lineout)
            rgb = lineout;
        else
            rgb = 8'h00;
    else
        rgb = 8'h00;
        
// set VGA read address to show disparity
always @ (hcount,vcount)
     vga_addr = (384*(vcount-96))+(hcount-128); // was hcount-128, red by 2 for read latency
endmodule