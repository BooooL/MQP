`timescale 1ns / 1ps
// Top module for future custom stereo camera IP package
module noip_top(
   input sw0,
   input sysclk,
   input reset, // reset 
   input cam_rst, // button for camera RESET_BAR
   input trigger, // button for camera trigger
   output cam_sysclk, // sysclk out to camera
   output cam_reset, // reset_bar out to camera
   output cam_trigger, // trigger out to camera
   input [7:0] FIFO_DATA, // DO[7:0] from AL422b fifo
   output FIFO_OE1, // read enable to fifo (active low)
   output FIFO_RRST1, // read reset to fifo (active low)
   output FIFO_OE2, // read enable to fifo (active low)
   output FIFO_RRST2, // read reset to fifo (active low)
   output FIFO_RCK, // rck to fifo (1MHz)
   output reg [7:0] rgb, // values on vga color pins
   output HS, // horizontal sync (to VGA port)
   output VS, // vertical sync (to VGA port)
   output [3:0] LEDs
   );
    
wire clk_200MHz, clk_50MHz, clk_25MHz, clk_24MHz, clk_5MHz;
clk_wiz_0 clkgen
   (
   // Clock in ports
    .clk_100MHz(sysclk),      // input clk_100MHz
    // Clock out ports
   // .clk_200MHz(clk_200MHz),     // output clk_200MHz
    .clk_50MHz(clk_50MHz),     // output clk_50MHz
    .clk_25MHz(clk_25MHz),     // output clk_25MHz
    .clk_24MHz(clk_24MHz),
    .clk_5MHz(clk_5MHz),
    // Status and control signals
    .reset(reset)
);

wire clk_20Hz;
clk_divs clks(
	.reset(reset), // synchronous reset
    .clk_24M(clk_24MHz), // 24MHz clock signal
    .clk_20Hz(clk_20Hz) // 20Hz clock pulse
    );
    
assign FIFO_RCK = clk_5MHz;
assign cam_sysclk = clk_24MHz;

// ~~~~~~~~~~ disparity code ~~~~~~~~~~~~~~
wire trig_db;
debounce deb(
    .clk(clk_20Hz),
    .btn(trigger),
    .btn_val(trig_db)
    );
    
//wire get_data;
wire buffer_ready, idle, result_wea;
wire [2:0] current_state;
wire [18:0] laddr, raddr, result_addr;
wire [7:0] ldata, rdata, result_data;
disparity disp(
	 .clk(clk_50MHz), // Read clk signal
	 .enable(trig_db), // enable new disparity calculation 
	 //.get_data(get_data),
	 .buffer_ready(buffer_ready),
	 .reset(reset), // reset disparity FSM
	 .ldata(ldata), // FIFO data in
	 .rdata(rdata), // FIFO data in
	 .laddr(laddr),
	 .raddr(raddr),
	 .result_addr(result_addr),
	 .result_data(result_data),
	 .result_wea(result_wea),
	 .idle(idle), // LED indicator signify end of process
	 .state_LED(current_state) // current state indicator
    );
    
// state indicator LEDs
//assign LEDs = {1'b0,buffer_ready,trigger,image_sel};
assign LEDs = {current_state[2:0],sw0};

// ~~~~~~~~~~~~~~~~ VGA controller ~~~~~~~~~~~~~~~~~~~~~~
wire [10:0] hcount, vcount;
wire blank;
vga_controller_640_60 vga(
    .rst(reset),
    .pixel_clk(clk_25MHz),
    .HS(HS),
    .VS(VS),
    .hcount(hcount),
    .vcount(vcount),
    .blank(blank)
    );

// ~~~~~~~~~~~~~~~~ Left, right, resultant image buffers ~~~~~~~~~~~~~~~~     
// camera initialization sequence
reg [11:0] init_count = 12'h000;
always @(posedge clk_24MHz) // cam sysclk before ODDR2
begin
	if (cam_rst) // if cam_rst is pressed, redo the initialization sequence
		init_count <= 12'h000;
	else if(init_count < 2500) // keep cam_rst asserted for at least 20 cam_sysclk cycles - I use 30 since it's the minimum time for the i2c bus to be ready
		init_count <= init_count + 1'b1;
end
assign cam_reset = (init_count >= 20);

wire fifo_oe, fifo_rrst, image_sel;
assign FIFO_OE1 = (image_sel == 1'b0) ? fifo_oe : 1'b1;
assign FIFO_OE2 = (image_sel == 1'b1) ? fifo_oe : 1'b1;
assign FIFO_RRST1 = (image_sel == 1'b0) ? fifo_rrst : 1'b1;
assign FIFO_RRST2 = (image_sel == 1'b1) ? fifo_rrst : 1'b1;

// shifts = 2x12, 1x9, 1x14 - avg~=12
imgbuf fifo_buffer(
    //.output_sel(sw0),
    .get_data(trig_db),
	//.href(hcount),
	//.vref(vcount),
	//.blank(blank),
	.laddr(laddr),
    .raddr(raddr),
    .ldata(ldata), 
    .rdata(rdata),
	.fifo_data(FIFO_DATA), // 8 bit data in from fifo
	.fifo_rck(clk_5MHz), // 1MHz clock signal generated by FPGA
	.bram_rck(clk_50MHz),
	.image_sel(image_sel),
	.fifo_rrst(fifo_rrst), // fifo read reset (reset read addr pointer to 0)
	.fifo_oe(fifo_oe), // fifo output enable (allow for addr pointer to increment)
	//.pixel_value(rgb), // 8-bit pixel value from internal buffer
	.trigger(cam_trigger),
	.buffer_ready(buffer_ready)
   );

wire [7:0] vga_data;
reg [18:0] vga_addr;       
blk_mem_resultant resultant (
  .clka(clk_50MHz),    // input wire clka
  .wea(result_wea),      // input wire [0 : 0] wea
  .addra(result_addr),  // input wire [18 : 0] addra
  .dina(result_data),    // input wire [7 : 0] dina
  .clkb(clk_25MHz),    // input wire clkb
  .addrb(vga_addr),  // input wire [18 : 0] addrb
  .doutb(vga_data)  // output wire [7 : 0] doutb
);
// ~~~~~~~~~~~~~~~~ End of image buffers ~~~~~~~~~~~~~~~~

// allow for VGA controller to read resultant image data
always @ (hcount,vcount,blank)
	if(blank)
		rgb = 8'h00;
	else if(128<=hcount && hcount <= 512 && vcount >= 96 && vcount <= 384 && sw0)
        rgb = vga_data;
    else if(~sw0 && hcount<384 && vcount <= 288)
        rgb = vga_data;
    else
        rgb = 8'h00;
 
always @(vcount,hcount)
    if(128<=hcount && hcount <= 512 && vcount >= 96 && vcount <= 384 && sw0)
        vga_addr = (384*(vcount-96))+(hcount-128);
    else if(~sw0)
        vga_addr = (384*vcount)+hcount;
endmodule
