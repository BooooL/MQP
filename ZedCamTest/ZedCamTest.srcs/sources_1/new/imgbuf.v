`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Module for reading from the AL422b FIFO and storing pixel line data in a 
// local buffer.
//////////////////////////////////////////////////////////////////////////////////
module imgbuf(
    input get_data, // trigger a new image capture
	input [10:0] href, // from microblaze, 0-751
	input [10:0] vref,
	input blank,
	input [7:0] fifo_data, // 8 bit data in from fifo
	input fifo_rck, // 1MHz clock signal generated by FPGA
	input vga_clk,
	output reg fifo_rrst, // fifo read reset (reset read addr pointer to 0)
	output reg fifo_oe, // fifo output enable (allow for addr pointer to increment)
	output reg [7:0] pixel_value, // 8-bit value from internal buffer
	//output [15:0] current_line, // value to seven segment displays
	output reg trigger
   );

reg reset_pointer; 
reg write_en; 
// reg get_data - moved to input w/ button press
wire [7:0] output_val;

parameter [1:0] ready = 2'b00;
parameter [1:0] read = 2'b01;
parameter [1:0] done = 2'b10;  
parameter [1:0] init = 2'b11;
reg buffer_ready;

reg [1:0] state = ready;
reg [1:0] prev_state, next_state = ready;
reg [9:0] pixel = 10'b00_0000_0000;
reg [15:0] num_lines = 16'h0000;

wire enb;
assign enb = ~blank;
reg [18:0] addra;
always @(href,vref)
    begin
    if(href >= 55 && href <694)
        addra = (640*vref)+(href-55);
    else
        addra = 18'd0;
    end
blk_mem_gen_0 bram(
    .clka(fifo_rck),
    .wea(write_en),
    .addra(addra), // 19 bits
    .dina(fifo_data), // 8 bits
    .clkb(vga_clk), 
    .enb(enb),
    .addrb({(640*vref)+href}), // 19 bits
    .doutb(output_val) // 8 bits
);

    
always @(posedge fifo_rck)
	state <= next_state;
	
always @(state,get_data,num_lines,pixel)	
	case(state)
		ready: 
			begin
				if(get_data) 
				begin
					//trigger = 1'b0; // was = 1'b0
					next_state = init;
				end
				else
					next_state = ready;
					
				prev_state = ready;
			end
		init: 
			begin
				next_state = read;
				prev_state = init;
			end
		read: 
			begin
				if(num_lines == 479) // was pixel == 751
					next_state = done;
				else
					next_state = read;
					
				prev_state = read;
			end
		done: 
			begin
				next_state = ready;
				prev_state = done;
				//trigger = 1'b1;
			end
	endcase

always @(posedge fifo_rck)
begin
    case(state)
        // allow for VGA controller to read from pixel_line
		ready:
		    begin 
		    write_en <= 1'b0;
			fifo_rrst <= 1'b1; // make sure read addr doesn't get reset
			end
	   // prepare to read new data from the AL422 into local memory
		init: 
			begin
		    trigger <= 1'b1;
			pixel <= 10'b00_0000_000;
			buffer_ready <= 1'b0;
			fifo_oe <= 1'b0; // allow for read pointer to increment
			write_en <= 1'b1;
			end
		// read data in from the AL422 into local memory
		read: 
			begin
		    trigger <= 1'b0;
			if(next_state == done)
				fifo_oe <= 1'b1; // turn off read enable
			
			if((prev_state != init) && (pixel < 751)) // one cycle delay between init and valid data
					pixel <= pixel + 1'b1;
			else if(prev_state != init)
				begin
				pixel <= 10'b00_0000_0000;
				num_lines <= num_lines + 1'b1;
				end
			end
		// close out read sequence before returning to ready state
		done:
			begin
			buffer_ready <= 1'b1;
			fifo_rrst <= 1'b0;
			num_lines <= 16'h0000;
			write_en <= 1'b0;
			trigger <= 1'b0;
			end
		endcase
end

// allow for VGA controller to read stored pixel line at given addr if state==ready
always @ (buffer_ready, href, vref, blank, pixel_value)
    // clear output when VGA is blanking
	if(blank)
		pixel_value [7:0] = 8'h00;
    else 
		pixel_value = output_val;

endmodule
