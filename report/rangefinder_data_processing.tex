\subsection{Rangefinder Data Processing}
With proper communication and the project set up in the SDK, the data processing began.

\subsubsection{Programmable Software}
The Programmable Software (PS) is responsible for all of the communication with the rangefinder, in addition to formatting the data before it is sent to the Programmable Logic.
\par
The distance data acquisition command is transmitted by the PS when it receives a signal from the PL. Once the command is sent, there are two different pieces of information that the software captures: the distance data and the step count. The rangefinder transmits the distance data half a data point (one character) at a time, but it does not transmit the step count. As such, the software receives the distance data one character at a time. The first character is stored in a buffer until the second character is received. Once the second character is received the distance data buffer is updated to hold both characters, the step count is incremented, and then both are written to the memory register connected to the PL, described further in Section \ref{ssec:ps_pl}.

\subsubsection{Programmable Logic}
The Programmable Logic (PL) is responsible for all data processing, block memory manipulation, and outputting to VGA.
\par
The rangefinder encodes each data point before transmitting it. The uncoded data point is expressed with 12 bits, in order to cover the device's maximum distance of 4095 millimeters. To encode the data the 12 bits are separated into two 6-bit pieces, and then 30\textsubscript{16} is added to each. The resultant data point is comprised of two ASCII characters \cite{ascii}. The decoding process, taking place in the PL, is the inverse of encoding where 30\textsubscript{16} is subtracted from each character and then they are merged together \cite{urg04lx_datasheet}.
\par
Since the rangefinder provides the distance away from an object and the angle at which it was detected, the data is essentially expressed in the polar coordinate system \cite{polar_coordinates}. However, the sensor suite outputs data on a VGA screen which expresses data in the rectangular (Cartesian) coordinate system, so the data was converted from polar to rectangular coordinates. This was accomplished by using the step number which corresponds to an angle around a circle, as shown in Figure \ref{rangefinder_fov}.
\par
Converting from polar to rectangular coordinates requires basic trigonometry. Luckily, Xilinx supports a few options for performing trigonometry operations in the PL: a Coordinate Rotational Digital Computer (CORDIC) function, multiplier IP blocks, or Lookup Tables (LUTs). Due to latency concerns and ease of integration, we implemented a LUT with a multiplier instead of a CORDIC function. The values in the LUT were used to extract the horizontal and vertical components from the polar coordinate. Taking advantage of a circle's symmetry, the LUT only holds 256 values, which correspond to the amount of rangefinder data steps in one quadrant of a circle. Each step value is manipulated such that it corresponds to two addresses in the LUT: one for the horizontal scale factor, and one for the vertical scale factor.
\par
The LUT was set up in Vivado using a read-only BRAM IP core with a depth of 256, and was initialized by importing a coefficient file (.coe). The 256 values in the coefficient file were calculated by using Equation \ref{coe} for step values between 128 and 384, corresponding to one quadrant of a circle. Note that multiplying by 4096 equates to a 12-bit left shift, and is used to decrease error due to rounding in later data manipulation.

\begin{equation}
	\textrm{LUT}[step] = \sin((384-step)\times\dfrac{\pi}{180})\times4096
	\label{coe}
\end{equation}

This coordinate-axis transformation required both a horizontal and vertical scale factor, but only one address in the BRAM can be read from at a time. To avoid read conflicts, the 256-address LUT was split into two 129-address LUTs, where one LUT corresponds to $0^\circ{}\leq{}\theta{}\leq45^\circ$, and the other corresponds to $45^\circ{}\leq{}\theta{}\leq90^\circ$. Separating the LUT to solve this problem takes advantage of the property that sine and cosine are $90^\circ$ out of phase with each other\footnote{This process could have been avoided by setting up the BRAM in a True Dual Port ROM configuration, so that there are two separate, individually addressable address busses for the same BRAM block.}. The code for the coefficient files can be found in Appendix \ref{coe_file}.
\par
Once the LUT was customized, the BRAM IP Wizard window specifies the BRAM's latency. In this case, once the addresses are calculated there is a latency of 2 clock cycles before the data from the LUT is valid. Once the horizontal and vertical data is valid, each is multiplied by the decoded polar coordinate data point by being input to a Multiplier IP block which in this case has a latency of 4 clock cycles. This transformation converts the data from polar to rectangular coordinates. After this step, the data is right-shifted in a manner such that the data points are scaled according to a VGA screen with a 640x480 pixel resolution. Next the data was localized to the device's location, so the x- and y-coordinates were shifted by the device's location. After this step, the x- and y-location accurately reflect the distance data localized to the device. The rangefinder's data processing module is found in Appendix \ref{rangefinderDP}.
\par
With proper x- and y-coordinates, the data is ready to be stored in memory. Another BRAM IP was created for this purpose. The VGA resolution is 640x480, so the BRAM requires 307,200 addresses\footnote{$640\times480 = 307,200$ addresses.}. This BRAM IP was customized to function in the write-first, dual port configuration. We implemented this BRAM module such that one port is a write-only port using our 100 MHz clock, and the other is a read-only port using our 60 Hz VGA clock. This BRAM IP avoids memory access conflicts by writing to memory before attempting to read. The write address was calculated by using Equation \ref{vga_wequation} with another Multiplier IP block.

\begin{equation}
	\textrm{write address} = (640\times{}y\textsubscript{location})+ x\textsubscript{location}
	\label{vga_wequation}
\end{equation}

\par
With the data stored in memory, it was output to a VGA screen. To control the VGA logic, Digilent's VHDL VGA controller module, found in Appendix \ref{vga_controller}, was implemented. In addition, the ZedBoard's VGA pins were configured in a constraints file (.xdc) to support 12-bit color resolution \cite{zedboard_datasheet}. Similar to Equation \ref{vga_wequation}, Equation \ref{vga_requation} was used to calculate the read address of the VGA BRAM IP.

\begin{equation}
	\textrm{read address} = (640\times{}v\textsubscript{count})+ h\textsubscript{count}
	\label{vga_requation}
\end{equation}


