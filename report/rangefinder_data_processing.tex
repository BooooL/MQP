\subsection{Rangefinder Data Processing}
The rangefinder's implementation into the system had two distinct pieces: communication and data processing. Since the ZedBoard SoC contains both an ARM processor and FPGA fabric, the design was optimized by utilizing both parts of the SoC for their unique advantages. As mentioned in Chapter \ref{systemDesign}, Xilinx offers a pre-configured UART peripheral driver through the ARM processor. As such, the Programmable Software (PS) was responsible for all of the communication with the rangefinder, in addition to pre-processing the data before it was written to the Programmable Logic (PL), where the FPGA was used to parallelize the data processing, block memory manipulation, and output VGA logic.

\subsubsection{Programmable Software}
To begin the data transaction, the distance data acquisition command was transmitted by the PS when it received signals from the PL. Once the command was sent, there were two different pieces of information that the software captured: the distance data and the step count. The rangefinder transmitted the distance data half a data point (one character) at a time. The first character was stored in a buffer until the second character was received. Once the second character was received, the distance data buffer was updated to hold both characters, the step count was incremented, and then both were written to the memory register connected to the PL, described further in Section \ref{ssec:ps_pl}.

\subsubsection{Programmable Logic}
When the PL receives the distance data and step count, the data begins its decoding process since the rangefinder encodes each data point before transmitting it. The decoded data point was expressed by 12 bits, in order to cover the rangefinder's maximum coverage distance of 4095 millimeters.\footnote{ 2\textsuperscript{12} - 1 = 4095} The rangefinder encoded the data by separating the 12-bit data into two 6-bit pieces, and then adding 30\textsubscript{16} to each. The resultant data point was comprised of two ASCII characters \cite{ascii}. The decoding process which took place in the PL was the inverse of encoding, where 30\textsubscript{16} was subtracted from each character and then they were merged together MSB first\cite{urg04lx_datasheet}.
\par
Since the rangefinder provided the distance away from an object and the angle at which it was detected, the data was essentially expressed in the polar coordinate system \cite{polar_coordinates}. In order to output the data on a VGA screen, the data was converted from polar to rectangular coordinates. This was accomplished by using the step number, since it corresponded to an angle around the rangefinder's detection circle, as shown in Figure \ref{rangefinder_fov}. Note the angular rotation per step was calculated by using Equation \ref{degrees_per_step}. Accordingly, each step around the rangefinder's field of view corresponded to a change of $0.3515625^\circ$.
\par
\begin{equation}
	\dfrac{360^\circ }{1024 \textrm{ steps}}  = 0.3515625^\circ \textrm{ per step}
	\label{degrees_per_step}
\end{equation}
\par
The transformation from polar to rectangular coordinates required basic trigonometry. Xilinx supports a few options for performing trigonometry operations in the PL: a Coordinate Rotational Digital Computer (CORDIC) function, multiplier IP blocks, or Lookup Tables (LUTs). Due to latency concerns and ease of integration, a LUT with a multiplier was implemented instead of a CORDIC function. The values in the LUT were used to extract the horizontal and vertical components from the polar coordinate. The LUT only held 256 values, which corresponded to the amount of rangefinder steps in one quadrant of the rangefinder's detection circle. Each step value corresponded to two addresses in the LUT: one scale factor for the detected object's horizontal distance away from the device, and one scale factor for the object's vertical distance away from the device
\par
The LUT was configured using a read-only BRAM IP core with a depth of 256, and was initialized by importing a coefficient file (.coe). The 256 values in the coefficient file were calculated by using Equation \ref{coe} for step values between 128 and 384, corresponding to one quadrant of the rangefinder's detection circle. Note that multiplying by 4096 equates to a 12-bit left shift, and was used to decrease error due to rounding in later data manipulation.

\begin{equation}
	\textrm{LUT}[step] = \sin((384-step)\times\dfrac{\pi}{180})\times4096
	\label{coe}
\end{equation}

This coordinate-axis transformation required both scale factors from the LUT at the same time, but it was only possible to access one address in the BRAM at a time. To avoid read conflicts, the 256-address LUT was split into two 129-address LUTs, where one LUT corresponded to $0^\circ{}\leq{}\theta{}\leq45^\circ$, and the other corresponded to $45^\circ{}\leq{}\theta{}\leq90^\circ$.\footnote{ This process could have been avoided by setting up the BRAM in a True Dual Port ROM configuration, so that there are two separate, individually addressable address busses for the same BRAM block.} The code for the coefficient files can be found in Appendix \ref{coe_file}.
\par
Once the LUT was customized, the BRAM IP Wizard window specifies the BRAM's latency. In this case, there was a latency of 2 clock cycles between the addresses being calculated and the data from the LUT being valid. Once the LUT data was valid, each was multiplied by the decoded polar coordinate data point by being wired to a Multiplier IP block. This multiplier carried a latency of 4 clock cycles in this case. This transformation converted the data from polar to rectangular coordinates. After this step, the data was localized to the device's location and then right-shifted so that the data was scaled properly and fit onto to a VGA screen with a 640x480 pixel resolution. After this step, each data point's x- and y-location accurately reflected the distance data localized to the device. The rangefinder's data processing module is found in Appendix \ref{rangefinderDP}.
\par
With proper x- and y-coordinates, each data point was stored in memory. Another BRAM IP was created for this purpose. Since the VGA resolution is 640x480, the BRAM required 307,200 addresses.\footnote{ $640\times480 = 307,200$ addresses.} This BRAM IP was customized to function in the write-first, dual port configuration. One port was used as a write-only port with the 100 MHz logic clock, and the other was used as a read-only port using the 60 Hz VGA clock. This BRAM IP avoids memory access conflicts by writing to memory before attempting to read. The write address was calculated by using Equation \ref{vga_wequation} with another Multiplier IP block.

\begin{equation}
	\textrm{write address} = (640\times{}y\textsubscript{location})+ x\textsubscript{location}
	\label{vga_wequation}
\end{equation}

\par
The data was output to the VGA screen from the BRAM module. To control the VGA logic, Digilent's VHDL VGA controller module, found in Appendix \ref{vga_controller}, was implemented. In addition, the ZedBoard's VGA pins were configured in a constraints file (.xdc) to support 12-bit color resolution \cite{zedboard_datasheet}. Similar to Equation \ref{vga_wequation}, Equation \ref{vga_requation} was used to calculate the read address of the VGA BRAM IP.

\begin{equation}
	\textrm{read address} = (640\times{}v\textsubscript{count})+ h\textsubscript{count}
	\label{vga_requation}
\end{equation}


