\subsection{Rangefinder Data Processing}
With the communication between the ZedBoard and rangefinder, and between the PS and PL functioning properly the data processing can begin.

\subsubsection{Programmable Software}
The Programmable Software (PS) is responsible for all of the communication with the rangefinder, in addition to formatting the data before it is sent to the Programmable Logic.
\par
The distance data acquisition command is transmitted by the PS when it receives a signal from the PL. Once the command is sent, there are two different pieces of information that the software needs to capture: the distance data and the step count. The rangefinder transmits the distance data half a data point (one character) at a time, but it does not transmit the step count. As such, the software receives the distance data one character at a time, so the first character is stored in a buffer until the second character is received. Once the second character is received the distance data buffer is updated to hold both characters, the step count is incremented, and then both are sent to the PL by writing them to the memory location referenced by it, as discussed in Section \ref{sssec:ps_pl}.

\subsubsection{Programmable Logic}
The Programmable Logic (PL) is responsible for all data processing, block memory manipulation, and outputting to VGA.
\par
The rangefinder encodes each data point before transmitting it. The uncoded data point is expressed with 12 bits, in order to cover the device's maximum distance of 4095 millimeters. The 12-bit data is separated into two 6-bit data points, and 30\textsubscript{16} is added to each. The resultant data point is comprised of two ASCII characters \cite{ascii}. The decoding process takes place in the PL, and is the inverse of encoding where 30\textsubscript{16} is subtracted from each character and then they are merged together \cite{urg04lx_datasheet}.
\par
Since the rangefinder provides the distance away from an object and the angle at which it was detected, the data is essentially expressed in the polar coordinate system \cite{polar_coordinates}. We will be outputting our data on a VGA screen which expresses data in the rectangular (Cartesian) coordinate system, so we must convert from polar to rectangular coordinates. This is accomplished by using the step number, which corresponds to an angle around a circle as shown in Figure \ref{rangefinder_fov}.
\par
Converting from polar to rectangular coordinates requires basic trigonometry. Luckily, Xilinx supports a few options for performing complex math operations in the PL: a Coordinate Rotational Digital Computer (CORDIC) function, multiplier IP blocks, or Lookup Tables (LUTs). Due to latency concerns and ease of integration, we decided to implement a LUT with a multiplier instead of a CORIC function. The values in the LUT will be used to extract the horizontal and vertical components from the polar coordinate. Taking advantage of a circle's symmetry, the LUT only needs to hold values 256 values, which correspond to the amount of rangefinder data steps in one quadrant of a circle. Each step value is manipulated such that it corresponds to two addresses in the LUT: one for the horizontal scale factor, and one for the vertical scale factor.
\par
The LUT was set up in Vivado using a read-only BRAM IP core with a depth of 256, and was initialized by importing a coefficient file (.coe). The 256 values in the coefficient file were calculated by using Equation \ref{coe} for step values between 128 and 384, corresponding to one quadrant of a circle. Note that multiplying by 4096 equates to a 12-bit left shift, and is used to decrease error due to rounding in later data manipulation.

\begin{equation}
	\textrm{LUT}[step] = \sin((384-step)\times\dfrac{\pi}{180})\times4096
	\label{coe}
\end{equation}

Only one address in the BRAM can be read from at a time, but we require both a horizontal and vertical scale factor. To avoid read conflicts, the 256-address LUT was split into two 129-address LUTs, where one LUT corresponds to $0^\circ{}\leq{}\theta{}\leq45^\circ$, and the other corresponds to $45^\circ{}\leq{}\theta{}\leq90^\circ$. Separating the LUT to solve this problem takes advantage of the property that sine and cosine are $90^\circ$ out of phase with each other\footnote{This process could have been avoided by setting up the BRAM in a True Dual Port ROM configuration, so that there are two separate, individually addressable address busses for the same BRAM block.}. The code for the coefficient files can be found in Appendix \ref{coe_file}.
\par
Once the LUT was customized, the BRAM IP Wizard window specifies the BRAM's latency. In this case, once the addresses are calculated there is a latency of 2 clock cycles before the data from the LUT is valid. Once the horizontal and vertical data is valid, each is multiplied by the decoded polar coordinate data point by being input to a Multiplier IP block which, in this case, has a latency of (LOOK UP LATENCY FOR MULTIPLIER). This transformation changes the data from polar to rectangular coordinates. After this step, the data is shifted back in a manner such that the data points will be able to fit on a VGA screen with resolution $640\times480$ pixels. Next the data needs to be localized to the device's location, so the x- and y-coordinates are shifted by the device's location. After this step, the x- and y-location accurately reflect the distance data localized to the device.
\par
With proper x- and y-coordinates, the data is ready to be stored in memory. Another BRAM IP was created for the VGA control. Our VGA resolution is $640\times480$, so our VGA BRAM requires 307,200 addresses. This BRAM IP was customized to function in the write-first, dual port configuration. We implemented this BRAM module such that one port is a write-only port using our 100 MHz clock, and the other is a read-only port using our 60 Hz VGA clock. This BRAM IP avoids memory access conflicts by writing to memory before attempting to read. Our write address was calculated by using another Multiplier IP with Equation \ref{vga_wequation}.

\begin{equation}
	\textrm{write address} = (640\times{}y\textsubscript{location})+ x\textsubscript{location}
	\label{vga_wequation}
\end{equation}

\par
With the data stored in memory, it is ready to be output to a VGA screen. We implemented a VHDL $640\times480$ VGA controller model by Digilent, found in Appendix \ref{vga_controller} ADD ANOTHER APPENDIX FOR CODE, to control our VGA logic. In addition, the ZedBoard's VGA pins were configured in a constraints file (.xdc) to support 12-bit color resolution \cite{zedboard_datasheet}. Similar to Equation \ref{vga_wequation}, Equation \ref{vga_requation} was used to calculate the read address of the VGA BRAM IP.

\begin{equation}
	\textrm{read address} = (640\times{}v\textsubscript{count})+ h\textsubscript{count}
	\label{vga_requation}
\end{equation}


